import xml.etree.ElementTree as ET
import mujoco
from typing import Optional, Any, Union
from enum import Enum
import numpy as np
from abc import ABC, abstractmethod

from aiml_virtual.simulated_object.moving_object import moving_object
from aiml_virtual.controller import controller, drone_geom_controller
from aiml_virtual.trajectory import trajectory, dummy_drone_trajectory

PROP_LARGE_COLOR = "0.1 0.02 0.5 1.0"


class Drone(moving_object.MovingObject):
    def __init__(self):  # in addition to typing, also check if all of these variables are necessary
        # Todo: idea: make these variables into Properties?
        super().__init__()
        self.sensors: dict[str, np.array] = {}  # storage for sensor data
        self.ctrl: list[np.ndarray] = [np.zeros(1)] * 4  # the thrust input allocated for each motor
        self.prop_qpos: list[np.ndarray] = [np.zeros(1)] * 4  # propeller angle in joint coordinate, for prop spin
        self.prop_angle: list[float] = [0, 0, 0, 0]  # propeller angle, used for visual propeller spin
        self.actr_force: list[np.ndarray] = [np.zeros(1)] * 4  # the actual thrust generated by the actuators
        self.state: dict[str, np.ndarray] = self.sensors  # just an alias for sensors actually
        self.ctrl_input: np.ndarray = np.zeros(4)  # the output of the controllers, before input allocation

    @property
    @abstractmethod
    def input_matrix(self) -> np.ndarray:
        pass

    @property
    def mass(self) -> Union[None, float, np.array]:
        # property to make sure that mass gets updated in case the model is updated. I haven't decided whether
        # to leave it as a numpy array of length 1 (which is what model.body().mass returns), or extract the float
        if self.model:
            return self.model.body(self.name).mass
        else:
            return None

    @property
    def inertia(self) -> Union[None, np.ndarray]:
        # property to make sure that inertia gets updated whenever the model is updated
        if self.model:
            return self.model.body(self.name).inertia
        else:
            return None

    @classmethod
    def get_identifiers(cls) -> Optional[list[str]]:
        # returning None opts out of XML parsing
        return None

    def spin_propellers(self):
        if self.sensors["pos"][2] > 0.015:
            self.prop_angle[0] += self.ctrl[0][0] * 100
            self.prop_angle[1] -= self.ctrl[1][0] * 100
            self.prop_angle[2] += self.ctrl[2][0] * 100
            self.prop_angle[3] -= self.ctrl[3][0] * 100
        for i in range(4):
            self.prop_qpos[i][0] = self.prop_angle[i]

    # todo: types
    def update(self, i: int, step: float) -> None:
        # todo: check this as compared to the original when cleaning up
        self.spin_propellers()
        setpoint = self.trajectory.evaluate(self.state, i, step, self.data.time)
        self.ctrl_input = self.controller.compute_control(state=self.state, setpoint=setpoint, time=self.data.time)
        motor_thrusts = self.input_matrix @ self.ctrl_input
        for i in range(4):
            self.ctrl[i][0] = motor_thrusts[i]

    def bind_to_data(self, data: mujoco.MjData):
        self.data = data
        self.sensors["ang_vel"] = self.data.sensor(self.name + "_gyro").data
        self.sensors["vel"] = self.data.sensor(self.name + "_velocimeter").data
        self.sensors["acc"] = self.data.sensor(self.name + "_accelerometer").data
        self.sensors["pos"] = self.data.sensor(self.name + "_posimeter").data
        self.sensors["quat"] = self.data.sensor(self.name + "_orimeter").data
        self.sensors["ang_acc"] = self.data.sensor(self.name + "_ang_accelerometer").data
        for i in range(4):
            prop_joint = self.data.joint(f"{self.name}_prop{i}")
            self.prop_qpos[i] = prop_joint.qpos
            self.prop_angle[i] = self.prop_qpos[i][0]
            self.ctrl[i] = self.data.actuator(f"{self.name}_actr{i}").ctrl
            self.actr_force[i] = self.data.actuator(f"{self.name}_actr{i}").force
        self.controller = drone_geom_controller.GeomControl(self.mass, self.inertia, self.model.opt.gravity)
        self.trajectory = dummy_drone_trajectory.DummyDroneTrajectory()




